"""
This type stub file was generated by pyright.
"""

from passlib.utils.decor import memoize_single_value

"""passlib.registry - registry for password hash handlers"""
log = ...
__all__ = ["register_crypt_handler_path", "register_crypt_handler", "get_crypt_handler", "list_crypt_handlers"]
class _PasslibRegistryProxy:
    """proxy module passlib.hash

    this module is in fact an object which lazy-loads
    the requested password hash algorithm from wherever it has been stored.
    it acts as a thin wrapper around :func:`passlib.registry.get_crypt_handler`.
    """
    __name__ = ...
    __package__ = ...
    def __getattr__(self, attr): # -> Any:
        ...
    
    def __setattr__(self, attr, value): # -> None:
        ...
    
    def __repr__(self): # -> Literal['<proxy module \'passlib.hash\'>']:
        ...
    
    def __dir__(self): # -> list[str]:
        ...
    


_proxy = ...
_UNSET = ...
_handlers = ...
_locations = ...
_name_re = ...
_forbidden_names = ...
def register_crypt_handler_path(name, path): # -> None:
    """register location to lazy-load handler when requested.

    custom hashes may be registered via :func:`register_crypt_handler`,
    or they may be registered by this function,
    which will delay actually importing and loading the handler
    until a call to :func:`get_crypt_handler` is made for the specified name.

    :arg name: name of handler
    :arg path: module import path

    the specified module path should contain a password hash handler
    called :samp:`{name}`, or the path may contain a colon,
    specifying the module and module attribute to use.
    for example, the following would cause ``get_handler("myhash")`` to look
    for a class named ``myhash`` within the ``myapp.helpers`` module::

        >>> from passlib.registry import registry_crypt_handler_path
        >>> registry_crypt_handler_path("myhash", "myapp.helpers")

    ...while this form would cause ``get_handler("myhash")`` to look
    for a class name ``MyHash`` within the ``myapp.helpers`` module::

        >>> from passlib.registry import registry_crypt_handler_path
        >>> registry_crypt_handler_path("myhash", "myapp.helpers:MyHash")
    """
    ...

def register_crypt_handler(handler, force=..., _attr=...): # -> None:
    """register password hash handler.

    this method immediately registers a handler with the internal passlib registry,
    so that it will be returned by :func:`get_crypt_handler` when requested.

    :arg handler: the password hash handler to register
    :param force: force override of existing handler (defaults to False)
    :param _attr:
        [internal kwd] if specified, ensures ``handler.name``
        matches this value, or raises :exc:`ValueError`.

    :raises TypeError:
        if the specified object does not appear to be a valid handler.

    :raises ValueError:
        if the specified object's name (or other required attributes)
        contain invalid values.

    :raises KeyError:
        if a (different) handler was already registered with
        the same name, and ``force=True`` was not specified.
    """
    ...

def get_crypt_handler(name, default=...):
    """return handler for specified password hash scheme.

    this method looks up a handler for the specified scheme.
    if the handler is not already loaded,
    it checks if the location is known, and loads it first.

    :arg name: name of handler to return
    :param default: optional default value to return if no handler with specified name is found.

    :raises KeyError: if no handler matching that name is found, and no default specified, a KeyError will be raised.

    :returns: handler attached to name, or default value (if specified).
    """
    ...

def list_crypt_handlers(loaded_only=...): # -> list[str]:
    """return sorted list of all known crypt handler names.

    :param loaded_only: if ``True``, only returns names of handlers which have actually been loaded.

    :returns: list of names of all known handlers
    """
    ...

ANY = ...
BUILTIN = ...
OS_CRYPT = ...
def has_backend(hasher, backend=..., safe=...):
    """
    Test if specified backend is available for hasher.

    :param hasher:
        Hasher name or object.

    :param backend:
        Name of backend, or ``"any"`` if any backend will do.
        For hashers without multiple backends, will pretend
        they have a single backend named ``"builtin"``.

    :param safe:
        By default, throws error if backend is unknown.
        If ``safe=True``, will just return false value.

    :raises ValueError:
        * if hasher name is unknown.
        * if backend is unknown to hasher, and safe=False.

    :return:
        True if backend available, False if not available,
        and None if unknown + safe=True.
    """
    ...

@memoize_single_value
def get_supported_os_crypt_schemes(): # -> tuple[()] | tuple[str, ...]:
    """
    return tuple of schemes which :func:`crypt.crypt` natively supports.
    """
    ...

def has_os_crypt_support(hasher): # -> Literal[False]:
    """
    check if hash is supported by native :func:`crypt.crypt` function.
    if :func:`crypt.crypt` is not present, will always return False.

    :param hasher:
        name or hasher object.

    :returns bool:
        True if hash format is supported by OS, else False.
    """
    ...

