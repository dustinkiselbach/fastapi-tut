"""
This type stub file was generated by pyright.
"""

import sys
import logging
import builtins
import __builtin__ as builtins
from itertools import imap, izip
from types import ModuleType

"""passlib.utils.compat - python 2/3 compatibility helpers"""
PY2 = ...
PY3 = ...
if sys.version_info < (2, 6) or (3, 0) <= sys.version_info < (3, 2):
    ...
PY26 = ...
JYTHON = ...
PYPY = ...
if PYPY and sys.pypy_version_info < (2, 0):
    ...
PYSTON = ...
log = ...
if PY3:
    ...
else:
    ...
def add_doc(obj, doc): # -> None:
    """add docstring to an object"""
    ...

__all__ = ['PY2', 'PY3', 'PY26', 'BytesIO', 'StringIO', 'NativeStringIO', 'SafeConfigParser', 'print_', 'int_types', 'num_types', 'unicode_or_bytes_types', 'native_string_types', 'u', 'unicode', 'uascii_to_str', 'bascii_to_str', 'str_to_uascii', 'str_to_bascii', 'join_unicode', 'join_bytes', 'join_byte_values', 'join_byte_elems', 'byte_elem_value', 'iter_byte_values', 'irange', 'imap', 'lmap', 'iteritems', 'itervalues', 'next', 'OrderedDict', 'nullcontext', 'get_method_function', 'add_doc']
_lazy_attrs = ...
if PY3:
    unicode = ...
    def u(s): # -> str:
        ...
    
    unicode_or_bytes_types = ...
    native_string_types = ...
else:
    unicode = ...
    def u(s):
        ...
    
    unicode_or_bytes_types = ...
    native_string_types = ...
unicode_or_bytes = ...
unicode_or_str = ...
join_unicode = ...
join_bytes = ...
if PY3:
    def uascii_to_str(s):
        ...
    
    def bascii_to_str(s): # -> str:
        ...
    
    def str_to_uascii(s): # -> str:
        ...
    
    def str_to_bascii(s): # -> bytes:
        ...
    
    join_byte_values = ...
    def byte_elem_value(elem): # -> int:
        ...
    
    def iter_byte_values(s): # -> bytes:
        ...
    
    def iter_byte_chars(s): # -> Generator[bytes, None, None]:
        ...
    
else:
    def uascii_to_str(s):
        ...
    
    def bascii_to_str(s): # -> bytes:
        ...
    
    def str_to_uascii(s):
        ...
    
    def str_to_bascii(s): # -> str:
        ...
    
    def join_byte_values(values): # -> bytes:
        ...
    
    join_byte_elems = ...
    byte_elem_value = ...
    def iter_byte_values(s): # -> Generator[int, None, None]:
        ...
    
    def iter_byte_chars(s): # -> bytes:
        ...
    
if PY3:
    int_types = ...
    num_types = ...
else:
    int_types = ...
    num_types = ...
if PY3:
    irange = ...
    def lmap(*a, **k): # -> list[Unknown]:
        ...
    
    imap = ...
    def iteritems(d):
        ...
    
    def itervalues(d):
        ...
    
    def nextgetter(obj):
        ...
    
    izip = ...
else:
    irange = ...
    lmap = ...
    def iteritems(d):
        ...
    
    def itervalues(d):
        ...
    
    def nextgetter(obj):
        ...
    
if PY3:
    method_function_attr = ...
else:
    method_function_attr = ...
def get_method_function(func): # -> Any | None:
    """given (potential) method, return underlying function"""
    ...

def get_unbound_method_function(func):
    """given unbound method, return underlying function"""
    ...

def error_from(exc, cause=...):
    """
    backward compat hack to suppress exception cause in python3.3+

    one python < 3.3 support is dropped, can replace all uses with "raise exc from None"
    """
    ...

suppress_cause = ...
if PY3:
    _lazy_attrs = ...
    print_ = ...
else:
    _lazy_attrs = ...
    def print_(*args, **kwds):
        """The new-style print function."""
        ...
    
if PY26:
    ...
else:
    ...
class _LazyOverlayModule(ModuleType):
    """proxy module which overlays original module,
    and lazily imports specified attributes.

    this is mainly used to prevent importing of resources
    that are only needed by certain password hashes,
    yet allow them to be imported from a single location.

    used by :mod:`passlib.utils`, :mod:`passlib.crypto`,
    and :mod:`passlib.utils.compat`.
    """
    @classmethod
    def replace_module(cls, name, attrmap): # -> Self@_LazyOverlayModule:
        ...
    
    def __init__(self, name, attrmap, proxy=...) -> None:
        ...
    
    def __getattr__(self, attr): # -> Any:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __dir__(self): # -> list[str]:
        ...
    


